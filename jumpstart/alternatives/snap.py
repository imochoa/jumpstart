#!/usr/bin/env python3

# stdlib imports
import logging
import pathlib
import re
import string
import typing as T

# 1st party imports
# from jumpstart.alternatives import AbstractAlternative
# from jumpstart.alternatives import AbstractAlternative
from jumpstart.alternatives.core import AbstractAlternative, auto_comment_re
from jumpstart.utils import filewrite_log, load_script, safe_open, similarity

logger = logging.getLogger(__name__)

valid_snap_chars = string.ascii_letters + string.digits + r"\-_ \t./"

snap_sources = [
    "--classic",
    "--edge",
]


class SnapAlternative(AbstractAlternative):
    dirname: str = "snap"

    def generate_std_files(self) -> bool:
        # with safe_open(self.install_script) as fp:
        #     lines = fp.readlines()
        lines = load_script(self.install_script)

        match_calls = (re.match(auto_comment_re, line) for line in lines)
        valid_matches = [m for m in match_calls if m is not None]

        if not valid_matches:
            return False

        match_dict = {m["section"]: m["data"] for m in valid_matches}
        pkgs_similarity = {k: similarity(k, "PKGS") for k in match_dict}
        pkgs_similarity = {k: v for k, v in pkgs_similarity.items() if v > 0.7}

        pkg_list = []
        if pkgs_similarity:
            best_k = max(pkgs_similarity, key=lambda k: pkgs_similarity[k])
            pkg_str = match_dict.pop(best_k)
            pkg_str = re.sub(r"[^" + valid_snap_chars + r"]", "", pkg_str.strip())
            pkg_list = pkg_str.split()
            for mod in snap_sources:

                try:
                    while True:
                        idx = pkg_list.index(mod)
                        if idx + 1 >= len(pkg_list):
                            pkg_list = pkg_list[:-1]
                        pkg_list[idx] = f"{pkg_list.pop(idx)} {pkg_list[idx]}"
                except ValueError:
                    pass

        logger.info("Writing the install script...")
        install_txt = r"#!/usr/bin/env sh"
        install_txt += "\n# AUTOGENERATED FILE! DO NOT MODIFY\n"

        if pkg_list:
            install_txt += "\n# >>>> PKGS: " + " ".join(pkg_list)
            install_txt += f"\nsudo apt-get install -y snapd"
            for pkg in pkg_list:
                install_txt += f"\nsudo snap install {pkg}"
        install_txt += "\n"

        with open(self.install_script, "w") as fp:
            fp.write(install_txt)
        filewrite_log(self.install_script)

        # Removing the sources
        for idx, pkg in enumerate(pkg_list):
            # sudo snap remove arduino
            components = pkg.split()
            if len(components) > 1:
                pkg_list[idx] = " ".join(c for c in components if c not in snap_sources)

        logger.info("Writing the remove script...")
        remove_txt = r"#!/usr/bin/env sh"
        remove_txt += "\n# AUTOGENERATED FILE! DO NOT MODIFY\n"

        if pkg_list:
            for pkg in pkg_list:
                # sudo snap remove arduino
                remove_txt += f"\nsudo snap remove {pkg}"
        remove_txt += "\n"

        with open(self.remove_script, "w") as fp:
            fp.write(remove_txt)
        filewrite_log(self.remove_script)

        logger.info("Writing the status script...")
        status_txt = r"#!/usr/bin/env sh"
        status_txt += "\n# AUTOGENERATED FILE! DO NOT MODIFY\n"
        status_txt += "\nmissing=0;\n"

        # if $(snap list | cut -f1 -d' ' | tail -n +2 | grep -q 'arduino')

        for pkg in pkg_list:
            status_txt += f"""
    if $(snap list | cut -f1 -d' ' | tail -n +2 | grep -q '{pkg}' )
    then
       echo "[{pkg}] -> [installed!]";
    else
       echo "[{pkg}] -> [NOT installed!]";
       missing=1;
    fi

        """
        #             status_txt += """
        # if [ "$missing" -eq "0" ];
        # then
        #     exit 0;
        # else
        #     exit 1;
        # fi
        #
        # """

        with open(self.status_script, "w") as fp:
            fp.write(status_txt)
        filewrite_log(self.status_script)
        return True
