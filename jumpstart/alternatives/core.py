#!/usr/bin/env python3

from __future__ import annotations

# stdlib imports
from abc import ABC, abstractmethod
import codecs
from collections import abc
from dataclasses import dataclass
import enum
import functools
import inspect
import json
import logging
import os
import pathlib
import typing as T

# 1st party imports
from jumpstart.utils import load_script, safe_open

logger = logging.getLogger(__name__)


# auto_comment_re = r'^#\s*>+\s*(?P<section>\S+)'
auto_comment_re = r"^#\s*>+\s*(?P<section>\S+)(?P<data>.*)$"


class InvalidDirname(ValueError):
    pass


class AbstractAlternative(ABC):
    dirname = ""

    def __init__(
        self,
        install_script: pathlib.Path,
        setup_script: pathlib.Path,
        update_script: pathlib.Path,
        remove_script: pathlib.Path,
        status_script: pathlib.Path,
    ):
        self.install_script = install_script
        self.setup_script = setup_script
        self.update_script = update_script
        self.remove_script = remove_script
        self.status_script = status_script

        super().__init__()

    def generate_std_files(self) -> bool:
        logger.info(f"No std file handler for {self}")
        return False

    @property
    def auto_shebang(self) -> str:
        return r"#!/usr/bin/env sh" "\n# DO NOT MODIFY!" "\n# THIS FILE WAS AUTOGENERATED" "\n"

    # @property
    # def install_txt(self) -> str:
    #     return load_script(self.install_script)

    # def write_status_script(self, txt):
    #
    #     with open(self.status_script, "w") as fp:
    #         # fp.write(txt)with open(self.status_script,'w') as fp:
    #         # fp.write(txt)
    #         logging.info(f"Would write... {self.status_script} \n{txt}")
    #     logger.info(f"Wrote {self.status_script} {self.status_script.stat().st_size / 1e3:.2f} [Kb]")

    # @property
    # def name(self) -> str:
    #     print("do!")
    #     return "ho"

    # @abstractmethod
    # def refresh(self):
    #     print("Regenerate remove script...")
    #     print("Regenerate status script...")
    #     raise NotImplementedError("Should be defined in a child class!")

    # @abstractmethod
    # def generate_status_script(self):
    #     raise NotImplementedError("Should be defined in a child class!")

    @classmethod
    def from_dir(cls, dir: pathlib.Path) -> T.List[AbstractAlternative]:

        alt_dirs = [d for d in dir.iterdir() if d.is_dir()]

        alt_dict: T.Dict[T.Type[AbstractAlternative], T.List[AbstractAlternative]] = dict()
        for subcls in cls.__subclasses__():
            for alt_dir in alt_dirs:
                try:
                    obj = subcls.from_alt_dir(alt_dir)
                    alt_dict.setdefault(subcls, []).append(obj)
                except InvalidDirname:
                    pass
        # TODO check max one in each key

        return [vs[0] for vs in alt_dict.values()]

    @classmethod
    def from_alt_dir(cls, dir: pathlib.Path) -> AbstractAlternative:
        if not dir.name.lower() == cls.dirname.lower():
            raise InvalidDirname(f"Cannot be {cls} since {dir.name} != {cls.dirname}")

        return cls(
            install_script=dir / "install.sh",
            setup_script=dir / "setup.sh",
            remove_script=dir / "remove.sh",
            update_script=dir / "update.sh",
            status_script=dir / "status.sh",
        )
