#!/usr/bin/env python3

# stdlib imports
import logging
import pathlib
import re
import string
import typing as T

# 1st party imports
# from jumpstart.alternatives import AbstractAlternative
from jumpstart.alternatives.core import AbstractAlternative, auto_comment_re
from jumpstart.cli_utils import bcolors, colorize, debug, info
from jumpstart.utils import filewrite_log, load_script, safe_open, similarity

logger = logging.getLogger(__name__)

valid_apt_chars = string.ascii_letters + string.digits + r"\-_ \t."
valid_ppa_chars = valid_apt_chars + "/"

# # version! apt-cache policy google-chrome-stable | grep Installed: | rev | cut -d: -f1 | rev | cut -d- -f1

INSTALL_TEMPLATE = """
#!/usr/bin/env sh
# >>>> PPAS: shutter/ppa
# >>>> PKGS: shutter
"""


class AptAlternative(AbstractAlternative):
    """show this pls"""

    dirname = "apt"

    @classmethod
    def template(cls) -> None:
        info(f"{cls}")
        info("Install")
        debug(INSTALL_TEMPLATE)
        info("Remove -> autogenerated")
        info("Status -> autogenerated")

    def generate_std_files(self) -> bool:
        # with safe_open(self.install_script) as fp:
        #     lines = fp.readlines()
        lines = load_script(self.install_script)

        match_calls = (re.match(auto_comment_re, line) for line in lines)
        valid_matches = [m for m in match_calls if m is not None]

        if not valid_matches:
            return False

        match_dict = {m["section"]: m["data"] for m in valid_matches}
        pkgs_similarity = {k: similarity(k, "PKGS") for k in match_dict}
        pkgs_similarity = {k: v for k, v in pkgs_similarity.items() if v > 0.7}

        pkg_list = []
        if pkgs_similarity:
            best_k = max(pkgs_similarity, key=lambda k: pkgs_similarity[k])
            pkg_str = match_dict.pop(best_k)
            pkg_str = re.sub(r"[^" + valid_apt_chars + r"]", "", pkg_str.strip())
            pkg_list = sorted(set(pkg_str.split()))

        ppas_similarity = {k: similarity(k, "PPAS") for k in match_dict}
        ppas_similarity = {k: v for k, v in ppas_similarity.items() if v > 0.7}
        ppa_list = []
        if ppas_similarity:
            best_k = max(ppas_similarity, key=lambda k: ppas_similarity[k])
            ppa_str = match_dict.pop(best_k)
            ppa_str = ppa_str.replace("ppa:", "")  # added automatically later...

            ppa_str = re.sub(r"[^" + valid_ppa_chars + r"]", "", ppa_str)
            ppa_list = sorted(set(ppa_str.split()))

        deps_similarity = {k: similarity(k, "DEPS") for k in match_dict}
        deps_similarity = {k: v for k, v in deps_similarity.items() if v > 0.7}
        dep_list = []
        if deps_similarity:
            best_k = max(deps_similarity, key=lambda k: deps_similarity[k])
            dep_str = match_dict.pop(best_k)
            dep_str = re.sub(r"[^" + valid_apt_chars + r"]", "", dep_str)
            dep_list = sorted(set(dep_str.split()))

        logger.info("Writing the install script...")
        install_txt = r"#!/usr/bin/env sh"
        install_txt += "\n# AUTOGENERATED FILE! DO NOT MODIFY\n"

        if dep_list:
            install_txt += "\n# >>>> DEPS: " + " ".join(dep_list)
            for dep in dep_list:
                relpath = pathlib.Path(f"../../{dep}/apt/install.sh")

                dep_install_path = (self.install_script / "../../..").resolve() / dep / "apt/install.sh"
                if (self.install_script.parent / relpath).is_file():
                    install_txt += f'\n. "{relpath}"'
                else:
                    logger.error(f"Missing dependency at {dep_install_path}")
                    install_txt += f"\n# Missing file! {dep_install_path}"

        if ppa_list:
            install_txt += "\n# >>>> PPAS: " + " ".join(ppa_list)
            install_txt += "\nsudo apt-get install -y software-properties-common"
            for ppa in ppa_list:
                install_txt += f"\nsudo add-apt-repository -y ppa:{ppa}"
            install_txt += f"\nsudo apt-get update -y"

        if pkg_list:
            install_txt += "\n# >>>> PKGS: " + " ".join(pkg_list)

            install_txt += "\nsudo apt-get install -y \\\n\t" + " \\\n\t".join(pkg_list)
            # for pkg in pkg_list:
            #     install_txt +=f'\nsudo apt-get install -y {pkg}'
        install_txt += "\n"

        with open(self.install_script, "w") as fp:
            fp.write(install_txt)
        filewrite_log(self.install_script)

        logger.info("Writing the remove script...")
        remove_txt = r"#!/usr/bin/env sh"
        remove_txt += "\n# AUTOGENERATED FILE! DO NOT MODIFY\n"

        if ppa_list:
            for ppa in ppa_list:
                remove_txt += f"\nsudo add-apt-repository --remove -y ppa:{ppa}"
            # remove_txt +=f'\nsudo apt-get update -y'

        if pkg_list:
            for pkg in pkg_list:
                remove_txt += f"\nsudo apt-get remove -y {pkg}"
        remove_txt += "\n"

        with open(self.remove_script, "w") as fp:
            fp.write(remove_txt)
        filewrite_log(self.remove_script)

        logger.info("Writing the status script...")
        status_txt = r"#!/usr/bin/env sh"
        status_txt += "\n# AUTOGENERATED FILE! DO NOT MODIFY\n"
        status_txt += "\nmissing=0;\n"

        for pkg in pkg_list:
            status_txt += f"""
if $(apt list --installed '{pkg}' | grep -q "\\[installed\\]")
then
   echo "[{pkg}] -> [installed!]";
else
   echo "[{pkg}] -> [NOT installed!]";
   missing=1;
fi

    """
        #             status_txt += """
        # if [ "$missing" -eq "0" ];
        # then
        #     exit 0;
        # else
        #     exit 1;
        # fi
        #
        # """

        with open(self.status_script, "w") as fp:
            fp.write(status_txt)
        filewrite_log(self.status_script)

        logger.info("Writing the version script...")
        version_txt = r"#!/usr/bin/env sh"
        version_txt += "\n# AUTOGENERATED FILE! DO NOT MODIFY\n"

        for idx, pkg in enumerate(pkg_list):
            varname = f"V{idx}"
            version_txt += (
                f"\n{varname}=$(apt-cache policy {pkg}" " | grep Candidate: | rev | cut -d: -f1 | rev | cut -d- -f1)"
            )
            version_txt += f'\necho "{pkg} ->  [${{{varname}}}]"'

        with open(self.version_script, "w") as fp:
            fp.write(version_txt)
        filewrite_log(self.version_script)

        return True

        # apt-cache policy google-chrome-stable | grep Installed: | rev | cut -d: -f1 | rev | cut -d- -f1


#     def refresh(self):
#         m = re.search(
#             pattern=r"apt(?:-get)?\s+install(?:\s+-y)?(?P<pkgs>(?:\s[a-zA-Z0-9-_]+)+)\s*(;|\n|\b)",
#             string=self.install_txt,
#             # flags=re.MULTILINE,
#         )
#         pkgs = [] if not m else [p for p in m.groupdict().get("pkgs", "").split()]
#
#         # Status script...
#         status_txt = self.auto_shebang
#
#         status_txt += "\nmissing=0;\n"
#
#         for pkg in pkgs:
#             status_txt += f"""
# if $(apt list --installed '{pkg}' | grep -q "\\[installed\\]")
# then
#    echo "[{pkg}] -> [installed!]";
# else
#    echo "[{pkg}] -> [NOT installed!]";
#    missing=1;
# fi
#
#         """
#         status_txt += """
# if [ "$missing" -eq "0" ];
# then
#     echo "0";
# else
#     echo "1";
# fi
#
#         """
#
#         self.write_status_script(status_txt)
#
#     def generate_status_script(self):
#         pass

#
# def apt_status(pgks: T.List[str]) -> str:
#     """
#     Generate a *status.sh* script that checks the status of the apt-installed *pgks*
#     """
#
#     sh_txt = """#!/usr/bin/env sh
#
# # DO NOT MODIFY!
# # THIS FILE WAS AUTOGENERATED BY *generate-status-files.py*
#
# missing=0;
#
# """
#
#     for pkg in pgks:
#         sh_txt += f"""
# if $(apt list --installed '{pkg}' | grep -q "\\[installed\\]")
# then
#    echo "[{pkg}] -> [installed!]";
# else
#    echo "[{pkg}] -> [NOT installed!]";
#    missing=1;
# fi
#
# """
#     sh_txt += """
# if [ "$missing" -eq "0" ];
# then
#     exit 0;
# else
#     exit 1;
# fi
#
#
# """
#
#     return sh_txt
