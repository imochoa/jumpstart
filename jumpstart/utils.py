#!/usr/bin/env python3
# stdlib imports
import codecs
from difflib import SequenceMatcher
import logging
import os
import pathlib
import re
import stat
import typing as T

logger = logging.getLogger(__name__)


def similarity(a: str, b: str) -> float:
    """
    Compares 2 strings and returns a similarity between 0-1
    """
    return SequenceMatcher(None, a.lower(), b.lower()).ratio()


def safe_open(p: pathlib.Path) -> codecs.StreamReaderWriter:
    return codecs.open(str(p), "r", encoding="utf-8", errors="ignore")


def load_script(p: pathlib.Path) -> T.List[str]:
    """

    Removes trailing and leading whitespace and escaped line breaks
    ```
    echo "hello" \
    && echo "new line!"
    ```
    """
    with safe_open(p) as fp:
        lines = fp.readlines()

    txt = "\n".join(line.strip() for line in lines)
    return txt.replace("\\\n", " ").split("\n")


def filewrite_log(p: pathlib.Path, logger: logging.Logger = logger) -> None:
    logger.info(f"Wrote {p} {p.stat().st_size / 1e3:.2f} [Kb]")


#
#
# def load_script(p: pathlib.Path, comment_m: str = "#"):
#
#     with safe_open(p) as fp:
#         lines = fp.readlines()
#     txt = "\n".join(l.strip() for l in lines)
#     return txt.replace("\\\n", " ").split('\n')
#
#     lines = (l.strip() for l in lines)
#     lines = (l for l in lines if not l.startswith(comment_m))
#     lines = (l[: l.find(comment_m)] for l in lines)
#     lines = (l.strip() for l in lines)
#     lines = (l for l in lines if l)
#     # TODO Join escaped newlines
#     # lines = (ll if ll else ";" for ll in lines)
#     txt = "\n".join(lines)
#     txt = txt.replace("\\\n", " ")
#
#     # txt = re.sub(
#     #     pattern=r"\s*\\\n\s*",
#     #     repl=" ",
#     #     string=txt,
#     # )
#     #
#     # txt = re.sub(
#     #     pattern=r"\s+",
#     #     repl=" ",
#     #     string=txt,
#     # )
#
#     # txt = re.sub(
#     #     pattern=r";\s+;",
#     #     repl=";",
#     #     string=txt,
#     # )
#
#     return txt


class Votes(T.NamedTuple):
    apt: T.List[str] = []
    snap: T.List[str] = []
    curl: T.List[str] = []  # TODO
    wget: T.List[str] = []  # TODO
    other: T.List[str] = []


def snap_pkgs(txt: str) -> T.List[str]:
    """
    Check whether the *txt* contains an snap-installed package
    """
    m = re.search(
        # pattern=r"apt(?:-get)?\s+install(?:\s+-y)?(?P<pkgs>(?:\s+\S+)+)",
        pattern=r"snap\s+install(?:\s+-{1,2}\w+)*(?P<pkgs>(?:\s[a-zA-Z0-9-_]+)+)\s*(;|\n|\b)",
        string=txt,
        # flags=re.MULTILINE,
    )

    if not m:
        return []
    return [p for p in m.groupdict().get("pkgs", "").split()]


def other_pkgs(txt: str) -> T.List[str]:
    """
    Check whether the *txt* contains an custom-installed package (could be built from source or just an executable binary, for example)
    """
    # (?P<pkgs>(?:\s[a-zA-Z0-9-_]+)+)\s*(;|\n)
    # if 'p7zip' in txt:
    m = re.search(
        pattern=r"\b(wget|curl|git)\b",
        string=txt,
        # flags=re.MULTILINE,
    )

    if not m:
        return []

    return list(m.groups())


# def check_app(d: pathlib.Path) -> Votes:
#     """
#     Checks directory *d* to see if we can auto-generate a *status.sh* script
#     AKA if it was simply apt- or snap-installed
#     """
#
#     install_script = [f for f in d.iterdir() if f.name.startswith("AppFilenames.install.value")]
#
#     if not install_script:
#         print(f"No install script in {d}")
#         return Votes()
#     elif len(install_script) > 1:
#         print(f"Too many install scripts in {d}!")
#
#     txt = load_script(install_script[0])
#     # kwargs = {f: False for f in Votes._fields}
#     # with open(install_script[0], "r") as fp:
#     #     txt = fp.read()
#
#     v = Votes(
#         apt=apt_pkgs(txt),
#         snap=snap_pkgs(txt),
#         other=other_pkgs(txt),
#     )
#
#     # Known multiple matches?
#     if v.other and (v.apt or v.snap):
#         # The main source programs are all apt installed, so remove them from other
#         if d.name in {
#             "wget",
#             "git",
#             "curl",
#             "jq",
#             "networking",
#         }:
#             v = Votes(
#                 apt=v.apt,
#                 snap=v.snap,
#             )
#
#     return v


# def snap_status(pgks: T.List[str]) -> str:
#     """
#     Generate a *status.sh* script that checks the status of the snap-installed *pgks*
#     """
#     sh_txt = """#!/usr/bin/env sh
#
# # DO NOT MODIFY!
# # THIS FILE WAS AUTOGENERATED BY *generate-status-files.py*
#
# missing=0;
# """
#
#     # snap list | cut -f1 -d' ' | tail -n +2 | grep 'spotify'
#     for pkg in pgks:
#
#         sh_txt += f"""
# if $(snap list | cut -f1 -d' ' | tail -n +2 | grep -q '{pkg}')
# then
#    echo "[{pkg}] -> [installed!]";
# else
#    echo "[{pkg}] -> [NOT installed!]";
#    exit 1;
# fi
#
# """
#
#     sh_txt += """
# if [ "$missing" -eq "0" ];
# then
#     exit 0;
# else
#     exit 1;
# fi
#
# """
#     return sh_txt


# def todo(d):
#     print(f"Install [{d.parent.name}] with [{d}]")


# fcn_dict = {
#     VALID_INSTALLTYPES.apt: todo,
#     VALID_INSTALLTYPES.snap: todo,
#     VALID_INSTALLTYPES.src: todo,
#     VALID_INSTALLTYPES.bin: todo,
# }


if __name__ == "__main__":
    print(
        """


    START


    """
    )

    # unknown_install_types: T.List[os.PathLike[str]] = []
    # for app_dir in (p for p in INDEX_DIR.iterdir() if p.is_dir()):
    #
    #     gg = (p for p in app_dir.iterdir() if p.is_dir())
    #     gg = ((d.name.lower(), d) for d in gg)
    #     installtypes = {k: d for k, d in gg if k in VALID_INSTALLTYPE_DICT}
    #
    #     for k, d in installtypes.items():
    #
    #         fcn_dict[k](d)

    # if d.name.lower() in VALID_INSTALLTYPE_DICT]

    # if VALID_INSTALLTYPES.snap
    # v = check_app(d)

    # print(d)
    # print(installtypes)
    # k_matches = [k for k, v in v._asdict().items() if v]
    # match_count = len(k_matches)
    # if match_count == 0:
    #     print(f"Unkown install type for {d}")
    #     unknown_install_types.append(d)
    #     continue
    # elif match_count > 1:
    #     print(f"Too many install types for {d}")
    #     unknown_install_types.append(d)
    #     continue
    # k = k_matches[0]
    # pkgs = getattr(v, k)

    # print(f"Just one install type: {k} -> {pkgs}")

    # fcn = {
    #     "apt": apt_status,
    #     "snap": snap_status,
    # }.get(k)
    # if fcn is None:
    #     print(f"No fcn for {k}!")
    #     continue

    # # with open
    # status_f = d / f"{AppFilenames.status.value}.sh"
    # with open(status_f, "w") as fp:
    #     fp.write(fcn(pkgs))

    # st = status_f.stat()
    # status_f.chmod(st.st_mode | stat.S_IEXEC)
    # print(f"Wrote {status_f} {st.st_size/1e3:.1f} [Kb]")

    # if unknown_install_types:
    # unknown_report = "\n\t> ".join(
    #     [f"\n[{len(unknown_install_types)}] Non-auto status scripts\n"]
    #     + [f.name for f in unknown_install_types]
    # )
    # print(unknown_report)


if __name__ == "__main__":
    pass
